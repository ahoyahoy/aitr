# Tech stack (high-level)

* **Nuxt 3** (SSR + Nitro server): chat + „časopisové“ UI, server routes, **SSE** stream
* **Upstash Redis** (serverless): cache, session, banditi, distance matrix
* **Upstash Vector**: embeddingy + semantické vyhledávání (vestavěný embedder)
* **DynamoDB**: per-tenant data (itineráře, event-sourcing)
* **S3**: snapshoty itinerářů, thumbnails, exporty
* **OSRM/Valhalla**: open-source routing microservice (Fargate)
* **OR-Tools (CP-SAT)**: VRP/TSP s time windows
* **QStash / EventBridge**: plánování ingestů a revalidací

# Data ingestion

* **Konektory**: Google Places/Maps (Places/Details/Distance Matrix), Skyscanner/Amadeus (lety), Booking, GetYourGuide/Viator (zážitky), GTFS/GTFS-RT.
* **Normalizace + geospatial**: schéma `Place{... h3, tags, opening_hours, price_level, popularity}`, **H3 r9–r10**; deduplikace (name+address+H3).
* **Pipelines**: idempotentní ETL (hash verze); HTTP-cache v Redis (`place:{source}:{id}`), backoff, circuit breaker.
* **Refresh**: QStash cron per city/region; fotky jako URL + krátký thumbnail cache v S3.

# Planning engine

* **Graf**: OSRM/Valhalla pro walk/bike/car; PT přes RAPTOR/CSA nad GTFS (+ GTFS-RT) nebo nejaký hotový api.
* **Optimalizace**: **OR-Tools** (TSP/VRP-TW), hard constraints (opening hours, check-in/out), soft (počasí, preference, rozpočet).
* **Validace**: `feasibility score` (slack, konflikty, penalizace), Monte Carlo na variance doby dojezdu.
  - Prakticky: generujeme náhodné variace cestovních časů a sledujeme, kolikrát itinerář selže.
* **Realtime replan**: při změně počasí/zpoždění nad práh → **LNS** lokální oprava.
* **Latency budget**: 200–400 ms retrieval, <2 s první feasible, streamujeme skeleton → detaily.

# Knowledge / Embeddings

* **Hybrid retrieval**: Upstash Vector (semantic) + reranking (cross-encoder) na top-50; fallback BM25 (Typesense/Meili).
* **Fragmentace a reuse**: ukládáme `Pattern`/`DayPlan`/`Leg` jako vektorové chunky s metadaty (`h3, season, tags, budget`).
* **Banditi**: Thompson sampling (Beta–Bernoulli) per slot (morning/lunch/afternoon); contextual TS (počasí, den, profil). Online update v Redis transakcích.

# mem0 – uživatelská paměť (dlouhodobá)

> Jednoduchá, rychlá „long-term memory“ vrstva pro preference a učení.

* **Cíle**: pamatovat si preference, negativní/pozitivní signály, minulé volby, vyhnutí duplicitám, personalizaci scoringu.

* **Struktura**:

  * `mem0:profile:{user}` – vektor preferencí (kuchyně, tempo, noise, rozpočet, indoor/outdoor, walking tolerance…)
  * `mem0:history:{user}` – poslední N itinerářů, kliky, konverze (bookings), explicitní feedback
  * `mem0:bandit:{user}:{slot}` – α/β parametry (TS), timestampy, decay
  * `mem0:blocks:{user}` – blacklist/avoid (místa/čtvrti/typy)

* **Úložiště**:

  * **Redis**: rychlé online hodnoty (α/β, counters, poslední signály) + TTL/decay
  * **DynamoDB**: trvalá historie (event-sourcing), periodic merge do profilu
  * **Upstash Vector**: vektory profilu a „oblíbených patternů“ (pro cold-start a rychlý recall)

* **Algoritmika**:

  * **Exponenciální decay** preferencí (časové vážení)
  * **Counterfactual logging** pro bandity (zapisujeme i zobrazené-nevybrané)
  * **Personalized rerank**: lineární model (logits) = base\_score + w·features(user, context, item)


# UX layer (časopisové UI + chat)

* **Nuxt**: story cards (denní spread), timeline + map strip, „what-if“ ovladače (čas, tempo, rozpočet).
* **Chat = orchestrátor nástrojů**: `search_places`, `plan_route`, `replan`, `book_hotel`, `explain_tradeoff`, `save_pattern`.
* **Explainability**: u každého kroku zdroj (citation), důvod (otevřeno, vzdálenost, počasí), přepínač alternativ (top-3).

# H3 distance matrix vs. Google Directions – náš hybrid

* **Proč H3/OSRM**: VRP/TSP potřebuje tisíce evaluací; **H3→H3** předvýpočet (r9–r10) snižuje páry z `n(n−1)/2` na `c(c−1)/2` (c = počet buněk ≪ n). Kost "zadarmo", nízká latence.
* **Jak to děláme**:

  1. Předpočítáme **H3→H3** matrice pro módy (walk/bike/car) a **time-of-day koše** (rush/normal/night). Uložíme do **Redis** (`cache:dist:{h3a}:{h3b}:{mode}:{tod}`, TTL 14–30 dní).
  2. **Solver** běží na H3 matici (rychlá aproximace).
  3. Top itineráře zpřesníme na **POI→POI** přes OSRM (levné) a porovnáme dif.
  4. **Truth pass pro uživatele**: posledních 5–15 legů spočítáme přes **Google Directions/Distance Matrix** kvůli live traffic + přesným pokynům.
  5. **ToS**: Google výsledky držíme jen dočasně pro zobrazení; dlouhodobou cache drží jen OSRM/H3.
* **PT**: H3 matice stavíme nad GTFS (RAPTOR/CSA) + průměrné zpoždění; finální konkrétní spoj vizualizujeme z vlastních výpočtů nebo on-demand.

# Data layer (konkrétně)

* **Redis (Upstash)**

  * `cache:dist:*`, `matrix:h3:*`, `place:*` (TTL), `session:{user}`, `bandit:{slot}`, `mem0:*`
  * rate-limit (token bucket), SWR revalidace přes QStash
* **Upstash Vector**

  * kolekce: `places`, `patterns`, `reviews`, `user_profiles`
  * metadata filtry: `h3, category, price, season`
* **DynamoDB**

  * `PK=tenant#user`, `SK=itinerary#id`; GSI pro `place_id`, `h3`
  * event stream (Kinesis) → analytics/evals
* **S3**

  * PDF/ICS exporty, map tiles, thumbnails (kratká expirace)

# Observabilita, kvalita, bezpečnost

* **OpenTelemetry**: front → tools → OR-Tools/OSRM/Google pass; každá citation = span
* **Evals**: offline rubriky (feasibility, novelty, preference fit), online A/B + bandit per-slot
* **Guardraily**: stropy nákladů (Google calls/req), failover: (1) H3 cache, (2) OSRM POI→POI, (3) heuristika bez OR-Tools
* **Multitenancy**: namespacy `tenant:{id}:*`, KMS, PII separátně

# Build pořadí (prakticky)

1. **Nuxt + Nitro**: SSE stream pro `plan()`, session v Redis
2. **OSRM microservice** + H3 utilita, Redis cache `cache:dist:*`
3. **Hybrid retrieval**: Upstash Vector (+ jednoduchý reranker) → kandidáti → map-to-H3
4. **OR-Tools TSP-TW** POC (6–12 bodů) → stream první feasible
5. **mem0**: feedback API → TS update α/β + profilový vektor → personalized rerank
6. **Truth pass**: integrace Google Directions na finální legy + citace/justifikace v UI
7. **Evals + tracing + cost guardrails**

# Mini-interfaces (náznak)

```ts
// server/routes/plan.post.ts (Nuxt/Nitro)
export default defineEventHandler(async (e) => {
  const req = await readBody(e)
  const ctx = await getSession(e) // Redis
  const candidates = await retrievePlaces(req, ctx) // Upstash Vector
  const matrix = await getH3Matrix(candidates, req.mode, req.tod) // Redis
  const plan = await solveTSPTW(matrix, candidates, req.constraints) // OR-Tools
  streamSkeleton(e, plan.skeleton)
  const refined = await refineWithOSRM(plan)
  const truth = await googleTruthPass(refined, limitLegs=12)
  return truth
})

type Place = {
  id: string
  source: 'gmaps'|'booking'|'skyscanner'|'guide'
  name: string
  lat: number
  lon: number
  h3: string
  tags: string[]
  openingHours?: { dow: number, start: string, end: string }[]
  rating?: number
  priceLevel?: 0|1|2|3|4
  popularity?: number
  raw?: any
}

type Itinerary = {
  id: string
  tenantId: string
  start: string
  end: string
  origin?: PlaceRef
  legs: Leg[]
  score: number
}

type Leg = {
  from?: PlaceRef
  to: PlaceRef
  departAt: string
  arriveAt: string
  mode: 'walk'|'car'|'bike'|'pt'
  reason: string // explanation
  citations: string[] // URLs/ids
}

```


Shrnutí: **stavíme rychlé, levné plánování na H3/OSRM, personalizujeme přes mem0 a bandity, a finální přesnost dodáme přes Google truth-pass.** Nuxt nám dá příjemné SSR/SSE a serverless provoz, Upstash řeší vektory i cache "zadara" v základu.
